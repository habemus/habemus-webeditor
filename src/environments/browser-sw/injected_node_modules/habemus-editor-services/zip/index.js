// third-party
const JSZip = require('jszip');

// third-party
const Bluebird = require('bluebird');

// own
const aux = require('./auxiliary');

module.exports = function (habemus, options) {

  if (!habemus.services.hDev) {
    throw new Error('habemus.services.hDev is required');
  }

  var zipService = {};

  /**
   * Unzips the given source / zip url (File) to the dest.
   * 
   * @param  {File|Path(String)|URL(String)} source
   * @param  {String} dest
   * @return {Bluebird}
   */
  zipService.unzip = function (source, dest) {

    if (!source) {
      throw new Error('source is required');
    }

    dest = dest || '/';

    var isURL = false;
    var zipContentsPromise;

    if (typeof source === 'string') {

      isURL = aux.isURL(source);

      if (isURL) {
        // assume it is an url for a zip file
        zipContentsPromise = habemus.services.http.fetchAsArrayBuffer(source);

      } else {
        // assume it is a path
        zipContentsPromise = habemus.services.hDev.readFile(source);
      }

    } else if (source instanceof window.File) {
      zipContentsPromise = aux.browserReadFile(source);
    }

    /**
     * Show the loading notification
     * and let it be manually removed
     */
    habemus.services.notification.loading.show({
      text: isURL ? 'Downloading and extracting' : 'Extracting',
      duration: Math.Infinity,
    });

    return zipContentsPromise.then(function (zipContents) {
      var zip = new JSZip();
      return zip.loadAsync(zipContents);
    })
    .then(function (zip) {

      // attempt to get a base path for all files within the zip
      var basePath = aux.parseZipBasePath(zip);
      var basePathRegExp = basePath ? new RegExp('^' + basePath) : false;

      var writesPromise = Object.keys(zip.files).map(function (filepath) {
        var file = zip.files[filepath];

        if (!file) {
          return;
        }

        if (file.dir) {
          // do nothing
          // console.log('found dir entry in zip file')
          return;
        }

        if (aux.isIgnoredFilepath(filepath)) {
          // ignore
          return;
        }

        var fileContents = file.async('arraybuffer');

        return file.async('arraybuffer').then(function (fileContents) {

          // remove the common base path if there is one
          var writeToPath = basePath ?
            filepath.replace(basePathRegExp, '') : filepath;

          return habemus.services.hDev.createFile(
            aux.pathJoin(dest, writeToPath),
            fileContents
          );
        });
      });

      return Bluebird.all(writesPromise);
    })
    .then(function (writes) {
      habemus.services.notification.loading.hide();
      habemus.services.notification.success.show({
        text: 'Successfully extracted ' + writes.length + ' files',
        duration: 3000,
      });
    })
    .catch(function (err) {
      habemus.services.notification.loading.hide();

      // let error propagate
      return Bluebird.reject(err);
    });
  };

  /**
   * Generates a zip file with all files within the given directory.
   * 
   * @param  {String} dirPath
   * @return {ArrayBuffer}
   */
  zipService.zip = function (dirPath) {

    // by default zip all files
    dirPath = dirPath || '/';

    var dirPathRegExp = new RegExp('^' + dirPath);

    return aux.recursiveReadDirectory(habemus.services.hDev, dirPath)
      .then(function (fileEntries) {

        var zip = new JSZip();

        return Bluebird.all(fileEntries.map(function (entry) {
          return habemus.services.hDev.readFile(entry.path).then(function (contents) {
            zip.file(
              entry.path.replace(dirPathRegExp, ''),
              contents
            );
          });
        }))
        .then(function () {
          return zip.generateAsync({ type: 'blob' });
        });
      });
  };

  return Bluebird.resolve(zipService);
};
