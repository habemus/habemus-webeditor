// third-party
const Bluebird = require('bluebird');

// constants
const STARTING_SLASH_RE = /^\//;
const TRAILING_SLASH_RE = /\/$/;

const IGORE_FILES = [
  /^__MACOSX/,
];

const URL_RE = /^https?:\/\/.+/;

// taken from https://github.com/hughsk/common-prefix/blob/master/index.js
// (thanks)
function _common(strings) {
  if (!Array.isArray(strings)) {
    throw new Error('common-prefix expects an array of strings')
  }

  var first = strings[0] || '';
  var commonLength = first.length

  for (var i = 1; i < strings.length; ++i) {
    for (var j = 0; j < commonLength; ++j) {
      if (strings[i].charAt(j) !== first.charAt(j)) {
        commonLength = j
        break
      }
    }
  }

  return first.slice(0, commonLength)
}


/**
 * Auxiliary function that reads a file reference from the browser
 * @param  {File} file
 * @return {Bluebird -> ArrayBuffer}
 */
exports.browserReadFile = function browserReadFile(file) {
  return new Bluebird(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      // resolve with the result
      resolve(reader.result);
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.onabort = function () {
      reject(new Error('file read aborted'));
    };
    
    // start reading
    reader.readAsArrayBuffer(file);
  });
};

/**
 * Basic path join that DOES NOT interpret relative paths.
 * 
 * @param  {String} p1
 * @param  {String} p2
 * @return {String}
 */
exports.pathJoin = function (p1, p2) {

  if ((typeof p1 !== 'string') || (typeof p2 !== 'string')) {
    throw new Error('paths MUST be strings');
  }

  return p1.replace(TRAILING_SLASH_RE, '') + '/' + p2.replace(STARTING_SLASH_RE, '');
};

/**
 * Checks whether a given file path should be ignored.
 * @param  {String}  filepath
 * @return {Boolean}
 */
exports.isIgnoredFilepath = function (filepath) {
  return IGORE_FILES.some(function (re) {
    return re.test(filepath);
  });
};

/**
 * Tests whehter the given string is an http(s) URL.
 * @param  {String}  str
 * @return {Boolean}
 */
exports.isURL = function (str) {
  return URL_RE.test(str);
};

/**
 * Parses the base path for the files within a zip archive.
 * 
 * @param  {JSZip} zip
 * @return {String}
 */
exports.parseZipBasePath = function (zip) {

  var filepaths = Object.keys(zip.files).filter(function (p) {
    return !exports.isIgnoredFilepath(p);
  });

  // attempt to find a common prefix for all files
  var commonPrefix = _common(filepaths);

  if (commonPrefix && zip.files[commonPrefix] && zip.files[commonPrefix].dir) {

    return commonPrefix;

  } else {
    // no common base directory
    return false;
  }
};

/**
 * Recursively readDirectory for filenames
 */
function recursiveReadDirectory(hDev, root, acc) {
  acc  = acc || [];
  root = root || '/';

  return hDev.readDirectory(root).then(function (entries) {

    var readDirectoryPromises = [];

    entries.forEach(function (entry) {
      if (entry.isFile) {
        acc.push(entry);
      } else if (entry.isDirectory) {
        readDirectoryPromises.push(recursiveReadDirectory(hDev, entry.path, acc));
      }
    });

    return Bluebird.all(readDirectoryPromises).then(function () {
      return acc;
    });
  });

};
exports.recursiveReadDirectory = recursiveReadDirectory;
